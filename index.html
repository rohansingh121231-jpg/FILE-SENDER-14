 <script>
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            document.getElementById('theme-icon-light').style.display = isDark ? 'block' : 'none';
            document.getElementById('theme-icon-dark').style.display = isDark ? 'none' : 'block';
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }

        if (localStorage.getItem('theme') === 'dark') {
            toggleTheme();
        }

        let html5QrCode = null;
        let isScanning = false;
        let hasScanned = false;
        let ALLOW_PEER_INIT = true;

        window.APP_PEER = null;
        window.APP_CONNECTION = null;
        window.IS_SWITCHING = false;

        function openScanner() {
            console.log('üì∑ Opening scanner...');
            hasScanned = false;
            document.getElementById('scanner-modal').classList.add('active');
            document.body.style.overflow = 'hidden';
            startScanner();
        }

        function closeScanner() {
            console.log('‚ùå Closing scanner...');
            document.getElementById('scanner-modal').classList.remove('active');
            document.body.style.overflow = '';
            stopScanner();
        }

        function startScanner() {
            if (html5QrCode || isScanning) {
                console.log('‚ö† Scanner already running');
                return;
            }
            isScanning = true;
            console.log('üé• Starting camera...');

            html5QrCode = new Html5Qrcode("qr-reader");
            
            const config = {
                fps: 30,
                qrbox: function(viewfinderWidth, viewfinderHeight) {
                    let minDimension = Math.min(viewfinderWidth, viewfinderHeight);
                    let qrboxSize = Math.floor(minDimension * 0.8);
                    return { width: qrboxSize, height: qrboxSize };
                },
                aspectRatio: 1.0,
                disableFlip: false
            };
            
            html5QrCode.start(
                { facingMode: "environment" },
                config,
                (decodedText) => {
                    if (hasScanned) {
                        console.log('‚ö† Already processed, ignoring...');
                        return;
                    }
                    hasScanned = true;
                    
                    console.log('‚úì‚úì‚úì QR SCANNED:', decodedText);
                    console.log('üîç Type:', typeof decodedText);
                    console.log('üîç Length:', decodedText.length);
                    
                    // Block peer init
                    ALLOW_PEER_INIT = false;
                    console.log('üö´ BLOCKED peer auto-init');
                    
                    if (navigator.vibrate) {
                        navigator.vibrate(200);
                    }
                    
                    // ‚úÖ‚úÖ‚úÖ CRITICAL FIX: Process BEFORE stopping scanner
                    console.log('‚Üí Processing QR NOW (before stopping scanner)...');
                    processQRCode(decodedText);
                    
                    // THEN stop scanner (async, won't interfere)
                    console.log('‚Üí Now stopping scanner...');
                    stopScanner();
                    closeScanner();
                },
                (errorMessage) => {
                    // Silent
                }
            ).catch((err) => {
                console.error('‚ùå Scanner error:', err);
                isScanning = false;
                alert('Camera error: ' + err.name);
                closeScanner();
            });
        }

        function processQRCode(decodedText) {
            console.log('=== PROCESSING QR CODE ===');
            console.log('URL:', decodedText);
            
            try {
                const url = new URL(decodedText);
                console.log('‚úì Valid URL');
                console.log('Hash:', url.hash);
                
                const scannedPeerId = url.hash.substring(1);
                console.log('üéØ Extracted Peer ID:', scannedPeerId);
                console.log('üéØ Length:', scannedPeerId.length);
                
                if (!scannedPeerId || scannedPeerId.trim() === '') {
                    console.error('‚ùå Empty peer ID!');
                    alert('QR code has no peer ID');
                    hasScanned = false;
                    ALLOW_PEER_INIT = true;
                    return;
                }
                
                console.log('‚úì Peer ID is valid');
                
                if (window.IS_SWITCHING) {
                    console.log('‚ö† Already switching, ignoring...');
                    return;
                }
                
                if (!window.switchToClientAndConnect) {
                    console.error('‚ùå‚ùå‚ùå Switch function NOT FOUND!');
                    alert('Error: App not ready');
                    hasScanned = false;
                    ALLOW_PEER_INIT = true;
                    return;
                }
                
                console.log('‚úì Switch function exists');
                window.IS_SWITCHING = true;
                console.log('üîÑ TRIGGERING CLIENT MODE SWITCH...');
                
                // Call switch function
                window.switchToClientAndConnect(scannedPeerId);
                
            } catch (e) {
                console.error('‚ùå‚ùå‚ùå QR parse FAILED:', e);
                console.error('Error:', e.message);
                alert('Invalid QR code: ' + e.message);
                window.IS_SWITCHING = false;
                hasScanned = false;
                ALLOW_PEER_INIT = true;
            }
        }

        function stopScanner() {
            if (html5QrCode && isScanning) {
                console.log('üõë Stopping scanner...');
                html5QrCode.stop().then(() => {
                    html5QrCode.clear();
                    html5QrCode = null;
                    isScanning = false;
                    console.log('‚úì Scanner stopped');
                }).catch((err) => {
                    console.error('Stop error:', err);
                    html5QrCode = null;
                    isScanning = false;
                });
            }
        }

        function showConnectionAnimation() {
            const overlay = document.getElementById('connection-overlay');
            overlay.classList.add('active');
            setTimeout(() => {
                overlay.classList.remove('active');
            }, 2000);
        }

        function updateDeliveryBoy(percent) {
            const deliveryBoy = document.getElementById('delivery-boy');
            if (deliveryBoy) {
                const position = (percent / 100) * 100;
                deliveryBoy.style.right = `${-45 + position}%`;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ App initialized');
            
            const statusEl = document.getElementById('status');
            const qrCodeContainer = document.getElementById('qr-code-container');
            const qrEl = document.getElementById('qrcode');
            const scanInstructions = document.getElementById('scan-instructions');
            const fileInput = document.getElementById('file-input');
            const transferStatusEl = document.getElementById('transfer-status');
            const shareButtonsContainer = document.getElementById('share-buttons-container');

            const nativeShareButton = document.getElementById('native-share-button');
            const copyLinkButton = document.getElementById('copy-link-button');
            const downloadQrButton = document.getElementById('download-qr-button');
            
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressPercentage = document.getElementById('progress-percentage');
            const progressSize = document.getElementById('progress-size');
            const progressEta = document.getElementById('progress-eta');
            const cancelButton = document.getElementById('cancel-button');
            
            const receiveProgressContainer = document.getElementById('receive-progress-container');
            const receiveProgressBar = document.getElementById('receive-progress-bar');
            const receiveProgressPercentage = document.getElementById('receive-progress-percentage');
            const receiveProgressSize = document.getElementById('receive-progress-size');

            const CHUNK_SIZE = 64 * 1024;

            let peer = null;
            let currentConnection = null;
            let myId = '';
            let connectUrl = '';
            let isHost = false;
            let connectionRetryCount = 0;
            const MAX_RETRY = 3;
            
            let fileQueue = [];
            let isSending = false;
            let isReceiving = false;
            let cancelTransfer = false;
            let hasActiveTransfer = false;
            let heartbeatInterval = null;
            
            window.addEventListener('beforeunload', (event) => {
                if (hasActiveTransfer || isSending || isReceiving) {
                    const warningText = 'Transfer active!';
                    event.preventDefault();
                    event.returnValue = warningText;
                    return warningText;
                }
            });

            function clearHashFromUrl() {
                const uri = window.location.toString();
                if (uri.indexOf("#") > 0) {
                    const cleanUri = uri.substring(0, uri.indexOf("#"));
                    window.history.replaceState({}, document.title, cleanUri);
                }
            }

            // DEFINE SWITCH FUNCTION FIRST
            window.switchToClientAndConnect = function(targetPeerId) {
                console.log('===================================');
                console.log('üîÑ SWITCHING TO CLIENT MODE');
                console.log('Target Peer:', targetPeerId);
                console.log('===================================');
                
                ALLOW_PEER_INIT = false;
                
                console.log('1Ô∏è‚É£ Hiding QR, showing connecting...');
                qrCodeContainer.style.display = 'none';
                shareButtonsContainer.style.display = 'none';
                scanInstructions.style.display = 'none';
                statusEl.textContent = 'üîó Connecting to peer...';
                transferStatusEl.textContent = 'Connecting...';
                
                console.log('2Ô∏è‚É£ Destroying old peer...');
                if (peer && !peer.destroyed) {
                    try {
                        peer.destroy();
                        console.log('‚úì Peer destroyed');
                    } catch (e) {
                        console.error('Peer destroy error:', e);
                    }
                }
                
                if (currentConnection) {
                    try {
                        currentConnection.close();
                    } catch (e) {}
                    currentConnection = null;
                }
                window.APP_CONNECTION = null;
                
                isHost = false;
                connectionRetryCount = 0;
                console.log('3Ô∏è‚É£ Mode set to CLIENT');
                
                console.log('4Ô∏è‚É£ Creating new client peer...');
                
                try {
                    peer = new Peer({
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { 
                                    urls: 'turn:openrelay.metered.ca:80',
                                    username: 'openrelayproject',
                                    credential: 'openrelayproject'
                                }
                            ],
                            sdpSemantics: 'unified-plan'
                        },
                        debug: 1
                    });
                    
                    window.APP_PEER = peer;
                    console.log('‚úì New peer created');
                    
                    peer.on('open', (newMyId) => {
                        console.log('‚úì‚úì New Peer ID:', newMyId);
                        myId = newMyId;
                        
                        console.log('5Ô∏è‚É£ Connecting to target:', targetPeerId);
                        attemptConnection(targetPeerId);
                    });
                    
                    peer.on('error', (err) => {
                        console.error('‚ùå Client peer error:', err.type);
                        if (err.type === 'peer-unavailable') {
                            if (connectionRetryCount < MAX_RETRY) {
                                connectionRetryCount++;
                                statusEl.textContent = `üîÑ Retry ${connectionRetryCount}`;
                                setTimeout(() => attemptConnection(targetPeerId), 2000);
                            } else {
                                statusEl.textContent = '‚ùå Not found';
                                showSwitchButton();
                                window.IS_SWITCHING = false;
                                hasScanned = false;
                                ALLOW_PEER_INIT = true;
                            }
                        } else {
                            window.IS_SWITCHING = false;
                            hasScanned = false;
                            ALLOW_PEER_INIT = true;
                        }
                    });
                    
                } catch (e) {
                    console.error('‚ùå Failed to create peer:', e);
                    statusEl.textContent = '‚ùå Error';
                    window.IS_SWITCHING = false;
                    hasScanned = false;
                    ALLOW_PEER_INIT = true;
                }
            };
            
            console.log('‚úì Switch function registered globally');

            function switchToHostMode(reason) {
                console.log('‚Üí Switch to host:', reason);
                clearHashFromUrl();
                
                if (peer && !peer.destroyed) {
                    try { peer.destroy(); } catch (e) {}
                }
                
                currentConnection = null;
                window.APP_CONNECTION = null;
                connectionRetryCount = 0;
                isHost = true;
                ALLOW_PEER_INIT = true;
                statusEl.textContent = 'üîÑ Creating QR...';
                
                setTimeout(() => initializePeer(), 1000);
            }

            function initializePeer() {
                if (!ALLOW_PEER_INIT) {
                    console.log('üö´ Peer init BLOCKED (scanner active)');
                    return;
                }
                
                console.log('üîß Initializing peer...');
                
                statusEl.textContent = 'Initializing...';
                
                try {
                    peer = new Peer({
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { 
                                    urls: 'turn:openrelay.metered.ca:80',
                                    username: 'openrelayproject',
                                    credential: 'openrelayproject'
                                }
                            ],
                            sdpSemantics: 'unified-plan'
                        },
                        debug: 1
                    });
                    
                    window.APP_PEER = peer;
                    
                } catch (e) {
                    console.error('‚ùå Init error:', e);
                    statusEl.textContent = '‚ùå Error';
                    return;
                }

                peer.on('open', (id) => {
                    myId = id;
                    console.log('‚úì Peer ID:', id);
                    const targetId = window.location.hash.substring(1);

                    if (targetId && !isHost) {
                        console.log('‚Üí CLIENT MODE');
                        isHost = false;
                        statusEl.textContent = 'üîó Connecting...';
                        attemptConnection(targetId);
                    } else {
                        console.log('‚Üí HOST MODE');
                        isHost = true;
                        qrCodeContainer.style.display = 'block';
                        scanInstructions.style.display = 'none';
                        
                        statusEl.textContent = 'Generating QR...';
                        
                        connectUrl = `${window.location.origin}${window.location.pathname}#${myId}`;
                        qrEl.innerHTML = '';
                        
                        new QRCode(qrEl, {
                            text: connectUrl,
                            width: 256,
                            height: 256,
                            colorDark: "#000000",
                            colorLight: "#ffffff",
                            correctLevel: QRCode.CorrectLevel.H
                        });
                        
                        shareButtonsContainer.style.display = 'flex';
                        setTimeout(setupShareButton, 100);
                        statusEl.textContent = '‚úÖ Ready';
                    }
                });

                peer.on('connection', (conn) => {
                    console.log('üì° Incoming connection');
                    if (currentConnection) {
                        conn.close();
                        return;
                    }
                    
                    statusEl.textContent = 'üì° Incoming...';
                    
                    if (conn.open) {
                        setupConnection(conn);
                    } else {
                        conn.on('open', () => setupConnection(conn));
                    }
                });

                peer.on('error', (err) => {
                    console.error('‚ùå Peer error:', err.type);
                    if (err.type === 'peer-unavailable') {
                        if (!isHost && connectionRetryCount < MAX_RETRY) {
                            connectionRetryCount++;
                            statusEl.textContent = `üîÑ Retry ${connectionRetryCount}`;
                            setTimeout(() => {
                                const targetId = window.location.hash.substring(1);
                                if (targetId) attemptConnection(targetId);
                            }, 2000);
                        } else if (!isHost) {
                            statusEl.textContent = '‚ùå Not found';
                            showSwitchButton();
                        }
                    }
                });
            }

            function showSwitchButton() {
                if (document.getElementById('switch-mode-btn')) return;
                
                const btn = document.createElement('button');
                btn.id = 'switch-mode-btn';
                btn.textContent = 'üîÑ Generate QR';
                btn.className = 'switch-mode-button';
                btn.onclick = () => {
                    btn.remove();
                    switchToHostMode('User requested');
                };
                document.querySelector('.transfer-area').appendChild(btn);
            }

            function attemptConnection(targetId) {
                console.log('‚Üí Attempting connection to:', targetId);
                let connectionFailed = false;
                let connectionTimer = null;
                
                const handleFailure = (message) => {
                    if (connectionFailed) return;
                    connectionFailed = true;
                    if (connectionTimer) clearTimeout(connectionTimer);
                    console.error('‚ùå Connection failed:', message);
                    
                    if (connectionRetryCount < MAX_RETRY) {
                        connectionRetryCount++;
                        statusEl.textContent = `üîÑ Retry ${connectionRetryCount}`;
                        setTimeout(() => attemptConnection(targetId), 2000);
                    } else {
                        statusEl.textContent = '‚ùå Failed';
                        showSwitchButton();
                        window.IS_SWITCHING = false;
                        hasScanned = false;
                        ALLOW_PEER_INIT = true;
                    }
                };

                try {
                    connectionTimer = setTimeout(() => handleFailure('Timeout'), 20000);
                    
                    const conn = peer.connect(targetId, { 
                        reliable: true,
                        serialization: 'binary'
                    });

                    conn.on('open', () => {
                        console.log('‚úì‚úì‚úì CONNECTION OPENED!');
                        clearTimeout(connectionTimer);
                        if (!connectionFailed) {
                            connectionRetryCount = 0;
                            window.IS_SWITCHING = false;
                            hasScanned = false;
                            ALLOW_PEER_INIT = true;
                            setupConnection(conn);
                        }
                    });

                    conn.on('error', (err) => {
                        console.error('‚ùå Connection error:', err);
                        handleFailure('Error');
                    });
                    
                    conn.on('close', () => {
                        console.log('‚ö† Connection closed early');
                        if (!currentConnection) handleFailure('Closed');
                    });
                } catch (e) {
                    console.error('‚ùå Connect exception:', e);
                    handleFailure('Failed');
                }
            }

            function setupConnection(conn) {
                console.log('‚úì Setup connection');
                currentConnection = conn;
                window.APP_CONNECTION = conn;
                showConnectionAnimation();
                
                statusEl.textContent = 'üîê Connected!';
                fileInput.disabled = false;
                transferStatusEl.textContent = '‚úÖ Ready';
                qrCodeContainer.style.display = 'none';
                shareButtonsContainer.style.display = 'none';
                scanInstructions.style.display = 'block';
                
                const switchBtn = document.getElementById('switch-mode-btn');
                if (switchBtn) switchBtn.remove();
                
                if (isHost) startHeartbeat();
                
                let incomingFileData = [];
                let fileMetadata = {};
                let receivedBytes = 0;

                setTimeout(() => {
                    if (currentConnection && currentConnection.open) {
                        currentConnection.send({ type: 'ready' });
                    }
                }, 100);

                conn.on('data', (data) => {
                    if (data.type === 'ready') {
                        statusEl.textContent = '‚úÖ Ready!';
                        return;
                    }
                    
                    if (data.type === 'heartbeat-ping') {
                        conn.send({ type: 'heartbeat-pong' });
                        return;
                    }
                    
                    if (data.type === 'heartbeat-pong') return;

                    if (data.type === 'metadata') {
                        fileMetadata = data;
                        incomingFileData = [];
                        receivedBytes = 0;
                        isReceiving = true;
                        hasActiveTransfer = true;
                        
                        transferStatusEl.textContent = `üì• ${fileMetadata.name}`;
                        receiveProgressContainer.style.display = 'block';
                        receiveProgressBar.style.width = '0%';
                        receiveProgressPercentage.textContent = '0%';
                        receiveProgressSize.textContent = `0 / ${formatBytes(fileMetadata.size)}`;
                    } else if (data.type === 'end') {
                        const fileBlob = new Blob(incomingFileData, { type: fileMetadata.type });
                        const downloadUrl = URL.createObjectURL(fileBlob);
                        const a = document.createElement('a');
                        a.href = downloadUrl;
                        a.download = fileMetadata.name;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        setTimeout(() => URL.revokeObjectURL(downloadUrl), 100);
                        
                        transferStatusEl.textContent = `‚úÖ Received`;
                        receiveProgressContainer.style.display = 'none';
                        isReceiving = false;
                        hasActiveTransfer = false;
                        incomingFileData = [];
                    } else if (data.type === 'cancel') {
                        transferStatusEl.textContent = '‚ùå Cancelled';
                        incomingFileData = [];
                        receiveProgressContainer.style.display = 'none';
                        isReceiving = false;
                        hasActiveTransfer = false;
                    } else {
                        incomingFileData.push(data);
                        receivedBytes += data.byteLength;
                        
                        const percent = Math.round((receivedBytes / fileMetadata.size) * 100);
                        receiveProgressBar.style.width = `${percent}%`;
                        receiveProgressPercentage.textContent = `${percent}%`;
                        receiveProgressSize.textContent = `${formatBytes(receivedBytes)} / ${formatBytes(fileMetadata.size)}`;
                    }
                });

                conn.on('close', () => handleDisconnect('Closed'));
                conn.on('error', () => handleDisconnect('Error'));
                
                if (fileQueue.length > 0 && !isSending) {
                    setTimeout(() => sendNextFileFromQueue(), 500);
                }
            }
            
            function startHeartbeat() {
                stopHeartbeat();
                heartbeatInterval = setInterval(() => {
                    if (currentConnection && currentConnection.open) {
                        try {
                            currentConnection.send({ type: 'heartbeat-ping' });
                        } catch (e) {}
                    }
                }, 5000);
            }

            function stopHeartbeat() {
                if (heartbeatInterval) {
                    clearInterval(heartbeatInterval);
                    heartbeatInterval = null;
                }
            }
            
            function handleDisconnect(message) {
                console.log('‚ö† Disconnect:', message);
                stopHeartbeat();
                if (!currentConnection && !peer) return;
                
                statusEl.textContent = '‚ö†Ô∏è Disconnected';
                transferStatusEl.textContent = 'Not connected';
                fileInput.disabled = true;
                
                if (currentConnection) {
                    try { currentConnection.close(); } catch (e) {}
                    currentConnection = null;
                    window.APP_CONNECTION = null;
                }
                
                isSending = false;
                isReceiving = false;
                hasActiveTransfer = false;
                fileQueue = [];
                progressContainer.style.display = 'none';
                receiveProgressContainer.style.display = 'none';
                
                setTimeout(() => switchToHostMode('Disconnected'), 1500);
            }

            fileInput.addEventListener('change', (event) => {
                for (const file of event.target.files) {
                    fileQueue.push(file);
                }
                event.target.value = null;
                transferStatusEl.textContent = `üìÅ ${fileQueue.length} queued`;
                
                if (currentConnection && currentConnection.open && !isSending) {
                    sendNextFileFromQueue();
                }
            });

            function sendNextFileFromQueue() {
                if (fileQueue.length === 0) {
                    isSending = false;
                    hasActiveTransfer = false;
                    transferStatusEl.textContent = '‚úÖ All sent!';
                    return;
                }
                
                if (!currentConnection || !currentConnection.open || isSending) return;
                
                isSending = true;
                hasActiveTransfer = true;
                cancelTransfer = false;
                const file = fileQueue.shift();
                
                transferStatusEl.textContent = `üì§ ${file.name}`;
                progressContainer.style.display = 'block';
                
                const startTime = Date.now();

                try {
                    currentConnection.send({
                        type: 'metadata',
                        name: file.name,
                        size: file.size,
                        fileType: file.type
                    });
                } catch (e) {
                    handleDisconnect('Send failed');
                    return;
                }

                let offset = 0;
                const reader = new FileReader();

                reader.onload = (e) => {
                    if (cancelTransfer) {
                        isSending = false;
                        hasActiveTransfer = false;
                        fileQueue = [];
                        progressContainer.style.display = 'none';
                        transferStatusEl.textContent = '‚ùå Cancelled';
                        if(currentConnection && currentConnection.open) {
                             try {
                                 currentConnection.send({ type: 'cancel' });
                             } catch (err) {}
                        }
                        return;
                    }
                    
                    if(!currentConnection || !currentConnection.open) {
                        isSending = false;
                        hasActiveTransfer = false;
                        handleDisconnect('Lost');
                        return;
                    }
                
                    try {
                        currentConnection.send(e.target.result);
                        offset += e.target.result.byteLength;
                        updateProgress(offset, file.size, startTime);

                        if (offset < file.size) {
                            readSlice(offset);
                        } else {
                            currentConnection.send({ type: 'end' });
                            isSending = false;
                            progressContainer.style.display = 'none';
                            sendNextFileFromQueue();
                        }
                    } catch (err) {
                        handleDisconnect('Error');
                    }
                };
                
                reader.onerror = (e) => {
                    isSending = false;
                    hasActiveTransfer = false;
                    transferStatusEl.textContent = '‚ùå Read error';
                    progressContainer.style.display = 'none';
                };

                function readSlice(o) {
                    const slice = file.slice(o, o + CHUNK_SIZE);
                    reader.readAsArrayBuffer(slice);
                }
                
                readSlice(0);
            }
            
            function updateProgress(sentBytes, totalBytes, startTime) {
                const percent = Math.round((sentBytes / totalBytes) * 100);
                progressBar.style.width = `${percent}%`;
                progressPercentage.textContent = `${percent}%`;
                progressSize.textContent = `${formatBytes(sentBytes)} / ${formatBytes(totalBytes)}`;
                updateDeliveryBoy(percent);
                
                const elapsedTime = (Date.now() - startTime) / 1000;
                if (elapsedTime > 0.5) {
                    const speed = sentBytes / elapsedTime;
                    const remainingBytes = totalBytes - sentBytes;
                    const remainingTime = remainingBytes / speed;
                    progressEta.textContent = `ETA: ${formatTime(remainingTime)}`;
                }
            }

            function formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }
            
            function formatTime(seconds) {
                if (seconds === Infinity || isNaN(seconds)) return '--:--';
                const min = Math.floor(seconds / 60);
                const sec = Math.floor(seconds % 60);
                return `${min}:${sec < 10 ? '0' : ''}${sec}`;
            }

            cancelButton.addEventListener('click', () => {
                cancelTransfer = true;
            });

            function setupShareButton() {
                const canvas = qrEl.querySelector('canvas');
                if (!canvas || typeof navigator.share === 'undefined') {
                    nativeShareButton.style.display = 'none';
                    copyLinkButton.style.display = 'inline-flex';
                    downloadQrButton.style.display = 'inline-flex';
                    return;
                }

                canvas.toBlob((blob) => {
                    if (!blob) {
                        nativeShareButton.style.display = 'none';
                        copyLinkButton.style.display = 'inline-flex';
                        downloadQrButton.style.display = 'inline-flex';
                        return;
                    }
                    
                    const file = new File([blob], 'qr-code.png', { type: 'image/png' });
                    const shareData = {
                        title: 'QR Send',
                        text: 'Scan to connect',
                        url: connectUrl,
                        files: [file]
                    };

                    if (navigator.canShare && navigator.canShare(shareData)) {
                        nativeShareButton.style.display = 'inline-flex';
                        copyLinkButton.style.display = 'none';
                        downloadQrButton.style.display = 'none';
                        nativeShareButton.onclick = async () => {
                            try {
                                await navigator.share(shareData);
                            } catch (err) {}
                        };
                    } else {
                        nativeShareButton.style.display = 'none';
                        copyLinkButton.style.display = 'inline-flex';
                        downloadQrButton.style.display = 'inline-flex';
                    }
                }, 'image/png');
            }

            function copyToClipboard(text, element) {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    if(element) {
                        const originalText = element.textContent;
                        element.textContent = '‚úÖ Copied!';
                        setTimeout(() => {
                            element.textContent = originalText;
                        }, 1500);
                    }
                } catch (err) {}
                document.body.removeChild(textarea);
            }
            
            function downloadQRCode() {
                try {
                    const canvas = qrEl.querySelector('canvas');
                    if (canvas) {
                        const dataUrl = canvas.toDataURL('image/png');
                        const a = document.createElement('a');
                        a.href = dataUrl;
                        a.download = 'qr-send.png';
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                    }
                } catch (e) {}
            }

            copyLinkButton.addEventListener('click', () => {
                if (connectUrl) copyToClipboard(connectUrl, copyLinkButton);
            });
            
            downloadQrButton.addEventListener('click', downloadQRCode);

            initializePeer();
        });
    </script>
